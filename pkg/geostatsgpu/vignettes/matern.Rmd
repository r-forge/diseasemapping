<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Matern correlations}
-->


# Matern correlations

```{r date}
date()
```


```{r packages, results='hide'}
library('geostatsp')
library('gpuR')

Ngrid = c(30, 40)
if(system("hostname", TRUE) == 'englishbreakfast') {
  setContext(2)
#  Ngrid = c(60, 80)
}
```


```{r memoryAvailable, echo=TRUE}
gpuInfo()$deviceName
gpuInfo()$maxAllocatableMem/(1024^3)
```

Set up spatial data

```{r setupData}
seqList = list( 
    x = seq(1,by=1,len=Ngrid[1]), 
    y = seq(201,by=1,len=Ngrid[2])
    )

coordsSp = sp::SpatialPoints(as.matrix(expand.grid(seqList$x, seqList$y)))

head(coordsSp@coords)

myParams = c(shape=2.15, range=2.5, variance = 2, nugget = 0, 
             anisoRatio = 10, 
             anisoAngleRadians = pi/7)
```


```{r simpleTestFloat}

  coordsGpu = vclMatrix(coordsSp@coords, 
                        nrow(coordsSp@coords), 
                        ncol(coordsSp@coords), type="float")
  print(coordsGpu[1:4,1:2])


  outputF = vclMatrix(0, nrow(coordsGpu), nrow(coordsGpu), type='float')

  
system.time(varGpu <- geostatsgpu::maternGpu(
  coordsGpu, output = outputF, param=myParams,
      workgroupSize = c(64L,4L), localSize = c(16L, 4L))
)
```

Use double precision if the GPU supports it

```{r simpleTestDouble}
if(gpuInfo()$double_support) {
  
  coordsGpuD = vclMatrix(coordsSp@coords, 
                         nrow(coordsSp@coords),
                         ncol(coordsSp@coords), type="double")



  outputD = vclMatrix(0, nrow(coordsGpuD), nrow(coordsGpuD), type='double')
  
  system.time(
  varGpuD <- geostatsgpu::maternGpu(
    x= coordsGpuD, output = outputD, param=myParams, 
      workgroupSize = c(64L,4L), localSize = c(16L, 4L))
  )
} else {
  varGpuD = NA
}
```


Create matern matrix on cpu

```{r maternMatGpu}
system.time(varCpu <- geostatsp::matern(coordsSp, myParams))
```

```{r compareCpuGpu}
theProb = c(0.5, 0.9, 0.99, 0.999,1)
quantile(abs(as.matrix(varCpu) - as.matrix(varGpu)), theProb, na.rm=TRUE)
quantile(abs(as.matrix(varCpu) - as.matrix(varGpuD)), theProb, na.rm=TRUE)
endSeq = seq(by=1, len=5, to=nrow(varCpu))
varCpu[endSeq,endSeq]
as.matrix(varGpu[endSeq,endSeq])
as.matrix(varGpuD[endSeq,endSeq])
```

# Batch matern

```{r paramsBatch}
myParamsBatch = rbind(
  c(shape=1.25, range=2.5, variance = 1.5, nugget = 0, 
             anisoRatio = 1, 
             anisoAngleRadians = 0), 
myParams, 
myParams * 0.8, myParams*1.2, myParams)
myParamsBatch = t(apply(myParamsBatch, 1, geostatsp::fillParam))
myParamsBatch
myParamsBatch = cbind(myParamsBatch, matrix(0, nrow(myParamsBatch), 22-ncol(myParamsBatch)))
paramsGpu =  vclMatrix(myParamsBatch, type='float')


coordsGpu2 = vclMatrix(cbind(1:4, c(1,2,1,2)), 
    type=gpuR::typeof(paramsGpu))
outputBatchF = vclMatrix(0, 
    nrow(paramsGpu)*nrow(coordsGpu2), nrow(coordsGpu2),
    type=gpuR::typeof(paramsGpu))
```


```{r batchMatern}
  geostatsgpu:::maternBatchBackend(
    outputBatchF,
    coordsGpu2, paramsGpu,  
    Nglobal = c(8L,8L), 
    Nlocal = c(2L, 2L))
as.matrix(outputBatchF)
```


Compare output to geostatsp's matern

```{r batchMaternCompare}

geostatsp::matern(
    x=SpatialPoints(as.matrix(coordsGpu2)),
    param=drop(myParamsBatch[1,1:7])
    )[1:4,1:4]
as.matrix(outputBatchF[1:4,1:4])
geostatsp::matern(
    x=SpatialPoints(as.matrix(coordsGpu2)),
    param=drop(myParamsBatch[2,1:7])
    )[1:4,1:4]
as.matrix(outputBatchF[nrow(coordsGpu2)+1:4,1:4])
```

# Cholesky


```{r cholBach}
varCpu = as.matrix(
  outputBatchF[1:ncol(outputBatchF), ]
  )
cholCpu = t(chol(varCpu))
theDiag = diag(cholCpu)
cholCpu = cholCpu %*% diag(1/theDiag)
theDiag = theDiag^2


diagMat = vclMatrix(0, nrow(paramsGpu), ncol(outputBatchF), type = gpuR::typeof(outputBatchF))
geostatsgpu:::cholBatchBackend(
  outputBatchF, diagMat, 
  Nglobal = c(4L,2L),
  Nlocal = c(2L,2L),
  NlocalCache = 1L)
as.matrix(outputBatchF)
varCpu
cholCpu
as.matrix(diagMat)
theDiag
```

# Multiplying lower triangle

```{r multLower}
Nsim = 2
Nmatrix = nrow(diagMat)
set.seed(0)
zmat = matrix(rnorm(ncol(outputBatchF) * Nsim * Nmatrix, mean=1,sd=0.001), ncol=Nsim)
zmatGpu = vclMatrix(zmat, type = gpuR::typeof(outputBatchF))


zmatMult = diag(as.vector(t(as.matrix(sqrt(diagMat))))) %*% zmat
rmat = mapply(function(DD, xx) {
  xx = xx[seq(1+(DD-1)*ncol(xx),len=ncol(xx)), ]
  xx[upper.tri(xx)] = 0
  diag(xx) = 1
  xx
  },
  DD = 1:Nmatrix,
  MoreArgs = list(xx=as.matrix(outputBatchF)),
  SIMPLIFY=FALSE)
rmat2 = do.call(Matrix::bdiag, rmat)


zmatGpu4 = deepcopy(-100*zmatGpu)
geostatsgpu:::multiplyLowerDiagonalBatchBackend(
  zmatGpu4, outputBatchF, diagMat, zmatGpu,
  diagIsOne = 1L,
  "sqrt",
  Nglobal = c(4L, 2L, 2L),
  Nlocal = c(2L,2L),
  NlocalCache = 2)


as.matrix(zmatGpu4)
rmat2 %*% zmatMult
```




# extra info

```{r gpuInfo, echo=TRUE}
gpuR::gpuInfo()
```




# To do

- fix crossprod

    - put crossprod in A and check it's ok
- each workgroup a row

    - use some of diagLocal for within-group sums
- dont store upper triangle in crossprod
- replace * with += for some iterators

