<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Matern correlations}
-->

```{r date}
date()
```

# Matern correlations

```{r packages}
library('geostatsp')
library('gpuR')
library('geostatsgpu')
```


Set up spatial data

```{r setupData}
# Ngrid = c(100, 100)
Ngrid = c(50, 50)

seqList = list( 
    x = seq(1,by=1,len=Ngrid[1]), 
    y = seq(201,by=1,len=Ngrid[2])
    )

coordsSp = sp::SpatialPoints(
	as.matrix(expand.grid(seqList$x, seqList$y)))

myParams = c(shape=4.5, range=1.5, variance = 2, 
	nugget = 0, anisoRatio = 10, 
	anisoAngleRadians = pi/7)
```

Transfer coordinates to GPU and create matrix on GPU to hold the variance matrix
```{r gpuObjects}
coordsGpu = vclMatrix(coordsSp@coords)

varMatGpu <- vclMatrix(
    data=-1, 
    length(coordsSp), length(coordsSp),
    type='double')
```

Create matern matrix on gpu
```{r maternMatGpu}
system.time(varCpu <- geostatsp::matern(coordsSp, myParams, type='variance'))
system.time(geostatsgpu::maternGpu(x=coordsGpu, param=myParams, output=varMatGpu, type='variance'))
range(varCpu - as.matrix(varMatGpu))
```


try cholesky
```{r chol}

myCoords = raster::as.data.frame(geostatsp::squareRaster(raster::extent(0,1,0,1), 90), xy=TRUE)[,1:2]
set.seed(0)
myCoords[,1] = myCoords[,1] + rnorm(nrow(myCoords), sd=0.1)
myCoords[,2] = myCoords[,2]^(1/2)+rnorm(nrow(myCoords), sd=0.1)

myMatR = as.matrix(geostatsp::matern(
    param=c(range=1, shape=1, variance=2),
    x=sp::SpatialPoints(myCoords)
    ))

dim(myMatR)
system.time(cholR <- chol(myMatR))

myMat = gpuR::vclMatrix(myMatR)
system.time(maternChol <- geostatsgpu:::cholGpu(myMat, verbose=TRUE, 
    MClocal = 64))

myMat2 = gpuR::vclMatrix(myMatR)
system.time(maternChol2 <- geostatsgpu:::cholGpu(myMat2, 
    MClocal = 128,
    verbose=TRUE))

myMat3 = gpuR::vclMatrix(myMatR)
system.time(maternChol3 <- geostatsgpu:::cholGpu(myMat3, 
    MClocal = 256,
    verbose=TRUE))

myMat4 = gpuR::vclMatrix(myMatR)
system.time(maternChol4 <- geostatsgpu:::cholGpu(myMat4, 
    MClocal = 512,
    verbose=TRUE))

```

```{r cholRes}
xchold = diag(cholR)
cholTest = t((diag(1/xchold) %*% cholR))
DfromR = xchold^2

LfromG = t(as.matrix(maternChol$L))
DfromG = as.vector(maternChol$D)

quantile(DfromR - DfromG)

quantile(
    LfromG[lower.tri(LfromG, diag=FALSE)] - 
    cholTest[lower.tri(LfromG, diag=FALSE)])

```


```{r diagPlot, eval=FALSE}
min(which(abs(as.vector(maternChol$D) - DfromR) > 0.1))
plot(DfromR - as.vector(maternChol$D))
```


```{r devtools}
#Rcpp::compileAttributes('..')
#devtools::document("..")
#devtools::install("..")
#devtools::reload("..")
```

```{r maternMatGpuChol}
cholVarGpu <- list(
    L = vclMatrix(
        data=-1, 
        length(coordsSp), length(coordsSp),
        type='double'),
    D = vclVector(data = -1, length=length(coordsSp), type='double')
    )

system.time(cholVarCpu <- geostatsp::matern(coordsSp, myParams, type='cholesky'))
system.time(fromGpu <- geostatsgpu::maternGpu(x=coordsGpu, param=myParams, output=cholVarGpu$L, DofLDL = cholVarGpu$D, type='cholesky'))

fromGpu$det 
sum(log(diag(cholVarCpu)))*2
```

```{r checkChol}
library('Matrix')
ldlL = new('dtrMatrix', x=as.vector(as.matrix(cholVarGpu$L)), Dim = dim(cholVarGpu$L), uplo='L')
ldlD = Diagonal(ncol(cholVarGpu$L),as.vector(cholVarGpu$D))

cholL = as(ldlL %*% sqrt(ldlD), 'dtrMatrix')

ldlL[1:5,1:5]
cholL[1:5,1:5]
range(cholL- cholVarCpu)
```


```{r compare}
centreCell = floor(prod(Ngrid)/2)+floor(Ngrid[2]/2)

myCol = mapmisc::colourScale(c(0, myParams['variance']),
    breaks = 9, dec=1, style='equal', transform='sqrt')

image(
    seqList$x, seqList$y, 
    matrix(as.matrix(varMatGpu)[centreCell,],Ngrid[1],Ngrid[2]),
    col = myCol$col, breaks=myCol$breaks)
mapmisc::legendBreaks("bottomright", myCol)


image(
    seqList$x, seqList$y, 
 matrix(as.matrix(varCpu)[centreCell,],Ngrid[1],Ngrid[2]),
    col = myCol$col, breaks=myCol$breaks)
mapmisc::legendBreaks("bottomright", myCol)
```

# extra info

```{r gpuInfo, echo=TRUE}
gpuR::gpuInfo()
```


```{r cholDebug, eval=FALSE, include=FALSE}
    file <- "geostatsgpu/inst/CL/cholGpu.cl"
    file <- system.file("CL", "cholGpu.cl", package = "geostatsgpu")

myCoords = raster::as.data.frame(geostatsp::squareRaster(raster::extent(0,1,0,1), 60), xy=TRUE)[,1:2]
set.seed(0)
myCoords[,1] = myCoords[,1] + rnorm(nrow(myCoords), sd=0.1)
myCoords[,2] = myCoords[,2]^(1/2)+rnorm(nrow(myCoords), sd=0.1)

x1 = as.matrix(geostatsp::matern(
    param=c(range=1, shape=1, variance=2),
    x=sp::SpatialPoints(myCoords)
    ))

x = gpuR::vclMatrix(x1)

        D = gpuR::vclVector(0, nrow(x),
            type='double',
            ctx_id = x@.context_index)

   kernel <- readChar(file, file.info(file)$size)

        localInfo = geostatsgpu:::gpuNlocal(
            kernel, 
            'sumLog',
            x@.device_index)

            MCtotal = localInfo$maxWorkgroupSize
            MClocal = localInfo$localWorkgroupSize
            sizeofDouble = localInfo$sizeOfDouble
            localStorage = 
            floor(
                localInfo$localMemory / 
                sizeofDouble)-2

    fromC = geostatsgpu:::cpp_cholGpu(
        x@address, 
        D@address,
        MCtotal,
        MClocal, 
        localStorage,
        x@.context_index - 1,
        kernel
        )
xchol = chol(x1)
xchold = diag(xchol)
cholTest = t((diag(1/xchold) %*% xchol))
gpuTest = as.matrix(x)
gpuTest = t(gpuTest)
quantile(
    gpuTest[lower.tri(gpuTest, diag=FALSE)] - 
    cholTest[lower.tri(gpuTest, diag=FALSE)])



xtest = cbind(
    xchold^2 , as.vector(D), xchold^2 - as.vector(D)
    )
#xtest#[1:40,]
#quantile(abs(xtest[,3]))



min(which(abs(xtest[,3]) > 0.1))

theSeq = 1:9
round(gpuTest[theSeq, theSeq],2)
round(cholTest[theSeq, theSeq],2)
cbind(gpuTest[,6], cholTest[,6])


max(apply( (cholTest - gpuTest),2,sd))

theSeq = 10:15
cholTest[theSeq,theSeq]
gpuTest[theSeq,theSeq]
as.vector(D)[theSeq]
(xchold^2)[theSeq]

range( (cholTest - gpuTest)[1:15,1:15])

#t(apply(cholTest - gpuTest, 2, range))


#(round(cholTest - gpuTest, 4))[1:60,1:9]
```
