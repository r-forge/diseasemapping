<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Matern correlations}
-->


# Matern correlations

```{r date}
date()
```


```{r packages, results='hide'}
library('geostatsp')
library('gpuR')
```


Set up spatial data

```{r setupData}
#Ngrid = c(100, 100)
#Ngrid = c(50, 50)
Ngrid = c(30, 30)

seqList = list( 
    x = seq(1,by=1,len=Ngrid[1]), 
    y = seq(201,by=1,len=Ngrid[2])
    )

coordsSp = sp::SpatialPoints(as.matrix(expand.grid(seqList$x, seqList$y)))

myParams = c(shape=2.15, range=1.5, variance = 2, nugget = 0, anisoRatio = 10, anisoAngleRadians = pi/7)
```


Create matern matrix on gpu
```{r maternMatGpu}
system.time(varCpu <- geostatsp::matern(coordsSp, myParams))
system.time(varGpu <- geostatsgpu::maternGpu(x=vclMatrix(coordsSp@coords, type='float'), param=myParams))
system.time(varGpuD <- geostatsgpu::maternGpu(x=vclMatrix(coordsSp@coords, type='float'), param=myParams))
quantile(varCpu - as.matrix(varGpu))
quantile(varCpu - as.matrix(varGpuD))
```

```{r compareCpuGpu}
varCpu[1:5,1:5]
as.matrix(varGpu)[1:5,1:5]
as.matrix(varGpuD)[1:5,1:5]
```

# Cholesky



```{r maternMatGpuC, eval=FALSE}
system.time(varCpuC <- geostatsp::matern(coordsSp, myParams, type='cholesky'))
system.time(varGpuC <- geostatsgpu::maternGpu(x=vclMatrix(coordsSp@coords, type='float'), param=myParams, 
    form='cholesky'))
system.time(varGpuCD <- geostatsgpu::maternGpu(x=vclMatrix(coordsSp@coords, type='double'), param=myParams, 
    form='cholesky'))
quantile(varCpuC - as.matrix(varGpuC))
quantile(varCpuC - as.matrix(varGpuCD))
```


# Cholesky again

Cholesky on the CPU
```{r cholCpu}
system.time(varCholGpu <- chol(varCpu))
```

Using `geostatsgpu`'s Cholesky
```{r cholGpu}
varMat1 = gpuR::deepcopy(varGpuD)
try(system.time(varCholGpu <- geostatsgpu:::cholGpu(varMat1)))
```

Using `gpuR`'s Cholesky
```{r cholGpurPackage}
varMat2 = gpuR::deepcopy(varGpuD)
system.time(varCholGpuR <- gpuR:::chol.vclMatrix(varMat2))
```

Using ViennaCL's LU decomposition
```{r cholViennaclLu}
varMat3 = gpuR::deepcopy(varGpuD)
system.time(varCholVcl <- geostatsgpu::luGpu(varMat3))
```

```{r cholGpuCompare, eval=FALSE}
xchold = diag(varGpuD)
cholTest = t((diag(1/xchold) %*% varCholGpu))
DfromR = xchold^2
quantile(DfromR - as.vector(varCholGpu$D), na.rm=TRUE)
```



# extra info

```{r gpuInfo, echo=TRUE}
gpuR::gpuInfo()
```




# To do

- fix crossprod

    - put crossprod in A and check it's ok
- each workgroup a row

    - use some of diagLocal for within-group sums
- dont store upper triangle in crossprod
- replace * with += for some iterators

