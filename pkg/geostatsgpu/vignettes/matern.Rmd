<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Matern correlations}
-->


# Matern correlations

```{r date}
date()
```


```{r packages, results='hide'}
library('geostatsp')
library('gpuR')
if(system("hostname", TRUE) == 'englishbreakfast') {
    setContext(2)
}
```


```{r memoryAvailable, echo=TRUE}
gpuInfo()$deviceName
gpuInfo()$maxAllocatableMem/(1024^3)
```

Set up spatial data

```{r setupData}
#Ngrid = c(100, 100)
#Ngrid = c(20, 20)
Ngrid = c(50, 50)

seqList = list( 
    x = seq(1,by=1,len=Ngrid[1]), 
    y = seq(201,by=1,len=Ngrid[2])
    )

coordsSp = sp::SpatialPoints(as.matrix(expand.grid(seqList$x, seqList$y)))

head(coordsSp@coords)

myParams = c(shape=2.15, range=2.5, variance = 2, nugget = 0, 
             anisoRatio = 10, 
             anisoAngleRadians = pi/7)
```


```{r simpleTestFloat}

  coordsGpu = vclMatrix(coordsSp@coords, 
                        nrow(coordsSp@coords), 
                        ncol(coordsSp@coords), type="float")
  print(coordsGpu[1:4,1:2])


  outputF = vclMatrix(0, nrow(coordsGpu), nrow(coordsGpu), type='float')

  
system.time(varGpu <- geostatsgpu::maternGpu(
  coordsGpu, output = outputF, param=myParams,
      workgroupSize = c(128L,2L), localSize = c(32L, 2L)))
```

Use double precision if the GPU supports it
```{r simpleTestDouble}
if(gpuInfo()$double_support) {
  
  coordsGpuD = vclMatrix(coordsSp@coords, 
                         nrow(coordsSp@coords),
                         ncol(coordsSp@coords), type="double")

  print(coordsGpuD[1:4,1:2])


  outputD = vclMatrix(0, nrow(coordsGpuD), nrow(coordsGpuD), type='double')
  
  system.time(
  varGpuD <- geostatsgpu::maternGpu(
    x= coordsGpuD, output = outputD, param=myParams, 
    workgroupSize = c(128L,2L), localSize = c(32L, 2L))
  )
} else {
  varGpuD = NA
}
```


Create matern matrix on cpu
```{r maternMatGpu}
system.time(varCpu <- geostatsp::matern(coordsSp, myParams))
theProb = c(0.5, 0.9, 0.99, 0.999,1)
quantile(abs(as.matrix(varCpu) - as.matrix(varGpu)), theProb, na.rm=TRUE)
quantile(abs(as.matrix(varCpu) - as.matrix(varGpuD)), theProb, na.rm=TRUE)
```

```{r compareCpuGpu}
varCpu[1:5,1:5]
as.matrix(varGpu)[1:5,1:5]
as.matrix(varGpuD)[1:5,1:5]
```

# Cholesky



```{r maternMatGpuC, eval=FALSE}
system.time(varCpuC <- geostatsp::matern(coordsSp, myParams, type='cholesky'))
system.time(varGpuC <- geostatsgpu::maternGpu(x=vclMatrix(coordsSp@coords, type='float'), param=myParams, 
    form='cholesky'))
system.time(varGpuCD <- geostatsgpu::maternGpu(x=vclMatrix(coordsSp@coords, type='double'), param=myParams, 
    form='cholesky'))
quantile(varCpuC - as.matrix(varGpuC), na.rm=TRUE)
quantile(varCpuC - as.matrix(varGpuCD), na.rm=TRUE)
```


# Cholesky again

Cholesky on the CPU
```{r cholCpu, eval=FALSE}
system.time(varCholGpu <- chol(varCpu))
```

Using `geostatsgpu`'s Cholesky
```{r cholGpu, eval=FALSE}
varMat1 = gpuR::deepcopy(varGpuD)
try(system.time(varCholGpu <- geostatsgpu:::cholGpu(varMat1)))
```

Using `gpuR`'s Cholesky
```{r cholGpurPackage, eval=FALSE}
varMat2 = gpuR::deepcopy(varGpuD)
system.time(varCholGpuR <- gpuR:::chol.vclMatrix(varMat2))
```

Using ViennaCL's LU decomposition
```{r cholViennaclLu, eval=FALSE}
varMat3 = gpuR::deepcopy(varGpuD)
system.time(varCholVcl <- geostatsgpu::luGpu(varMat3))
```

```{r cholGpuCompare, eval=FALSE}
xchold = diag(varGpuD)
cholTest = t((diag(1/xchold) %*% varCholGpu))
DfromR = xchold^2
quantile(DfromR - as.vector(varCholGpu$D), na.rm=TRUE)
```



# extra info

```{r gpuInfo, echo=TRUE}
gpuR::gpuInfo()
```




# To do

- fix crossprod

    - put crossprod in A and check it's ok
- each workgroup a row

    - use some of diagLocal for within-group sums
- dont store upper triangle in crossprod
- replace * with += for some iterators

