<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Matern correlations}
-->

```{r date}
date()
```

# Matern correlations

```{r packages}
library('geostatsp')
library('gpuR')
library('geostatsgpu')
```


Set up spatial data

```{r setupData}
# Ngrid = c(100, 100)
Ngrid = c(50, 50)

seqList = list( 
    x = seq(1,by=1,len=Ngrid[1]), 
    y = seq(201,by=1,len=Ngrid[2])
    )

coordsSp = sp::SpatialPoints(
	as.matrix(expand.grid(seqList$x, seqList$y)))

myParams = c(shape=4.5, range=1.5, variance = 2, 
	nugget = 0, anisoRatio = 10, 
	anisoAngleRadians = pi/7)
```

Transfer coordinates to GPU and create matrix on GPU to hold the variance matrix
```{r gpuObjects}
coordsGpu = vclMatrix(coordsSp@coords)

varMatGpu <- vclMatrix(
    data=-1, 
    length(coordsSp), length(coordsSp),
    type='double')
```

Create matern matrix on gpu
```{r maternMatGpu}
system.time(varCpu <- geostatsp::matern(coordsSp, myParams, type='variance'))
system.time(geostatsgpu::maternGpu(x=coordsGpu, param=myParams, output=varMatGpu, type='variance'))
range(varCpu - as.matrix(varMatGpu))
```

```{r cholDebug, eval=TRUE}
x1 = as.matrix(geostatsp::matern(
    param=c(range=1, shape=1, variance=2),
    x=as(geostatsp::squareRaster(raster::extent(0,1,0,1), 8), 'SpatialPoints')
    ))
x = gpuR::vclMatrix(x1)

        D = gpuR::vclVector(0, nrow(x),
            type='double',
            ctx_id = x@.context_index)

    file <- "geostatsgpu/inst/CL/cholGpu.cl"
    kernel <- readChar(file, file.info(file)$size)

        localInfo = geostatsgpu:::gpuNlocal(
            kernel, 
            'sumLog',
            x@.device_index)

            MCtotal = localInfo$maxWorkgroupSize
            MClocal = localInfo$localWorkgroupSize
            sizeofDouble = localInfo$sizeOfDouble
            localStorage = 50
            floor(
                0.5*localInfo$localMemory / 
                sizeofDouble)

    fromC = geostatsgpu:::cpp_cholGpu(
        x@address, 
        D@address,
        4,#MCtotal,
        2,#MClocal, 
        2,
        x@.context_index - 1,
        kernel
        )
xchol = chol(x1)
xchold = diag(xchol)

xtest = cbind(
    xchold^2 , as.vector(D), xchold^2 - as.vector(D)
    )
#xtest#[1:40,]
quantile(abs(xtest[,3]))
min(which(abs(xtest[,3]) > 0.1))

cholTest = (diag(1/xchold) %*% xchol)
gpuTest = as.matrix(x)
gpuTest[lower.tri(gpuTest)] = 0
range( (cholTest - gpuTest)[1:10,1:10])
cholTest[10:12,10:12]
gpuTest[10:12,10:12]
as.vector(D)[10:12]
(xchold^2)[10:12]

range( (cholTest - gpuTest)[1:15,1:15])

#t(apply(cholTest - gpuTest, 2, range))


#(round(cholTest - gpuTest, 4))[1:60,1:9]
```

try cholesky
```{r chol, eval=FALSE}
myMat = vclMatrix(as.matrix(geostatsp::matern(
    param=c(range=0.4, shape=1, variance=2),
    x=sp::SpatialPoints(cbind(runif(500), runif(500)))
    )))
as.matrix(myMat)[1:5,1:5]
myMatR = as.matrix(myMat)
system.time(cholR <- chol(myMatR))
system.time(maternChol <- geostatsgpu:::cholGpu(myMat, MCtotal = 64, MClocal = 16, localStorage=32, sizeOfDouble = 8, 
    verbose=TRUE))

names(maternChol)
maternChol$logDet
as.vector(maternChol$D)[1:5]
diag(cholR)[1:5]^2
```
```{r cholRes, eval=FALSE}
LfromG = as.matrix(maternChol$L)
LfromG[1:7,1:5]
DfromR = diag(cholR)^2

LfromR = diag(1/sqrt(DfromR)) %*% cholR
LfromR[1:7,1:5]
LfromG[lower.tri(LfromG, diag=FALSE)]=0
Ldiff = LfromR - LfromG
Ldiff[1:9, 1:5]
range(Ldiff)
varRecon = t(LfromG) %*% diag(as.vector(maternChol$D)) %*% LfromG
NN = 450
range((varRecon - myMatR)[1:NN,1:NN])
```


```{r diagPlot, eval=FALSE}
min(which(abs(as.vector(maternChol$D) - DfromR) > 0.1))
plot(DfromR - as.vector(maternChol$D))
```


```{r devtools}
#Rcpp::compileAttributes('..')
#devtools::document("..")
#devtools::install("..")
#devtools::reload("..")
```

```{r maternMatGpuChol}
cholVarGpu <- list(
    L = vclMatrix(
        data=-1, 
        length(coordsSp), length(coordsSp),
        type='double'),
    D = vclVector(data = -1, length=length(coordsSp), type='double')
    )

system.time(cholVarCpu <- geostatsp::matern(coordsSp, myParams, type='cholesky'))
system.time(fromGpu <- geostatsgpu::maternGpu(x=coordsGpu, param=myParams, output=cholVarGpu$L, DofLDL = cholVarGpu$D, type='cholesky'))

fromGpu$det 
sum(log(diag(cholVarCpu)))*2
```

```{r checkChol}
library('Matrix')
ldlL = new('dtrMatrix', x=as.vector(as.matrix(cholVarGpu$L)), Dim = dim(cholVarGpu$L), uplo='L')
ldlD = Diagonal(ncol(cholVarGpu$L),as.vector(cholVarGpu$D))

cholL = as(ldlL %*% sqrt(ldlD), 'dtrMatrix')

ldlL[1:5,1:5]
cholL[1:5,1:5]
range(cholL- cholVarCpu)
```


```{r compare}
centreCell = floor(prod(Ngrid)/2)+floor(Ngrid[2]/2)

myCol = mapmisc::colourScale(c(0, myParams['variance']),
    breaks = 9, dec=1, style='equal', transform='sqrt')

image(
    seqList$x, seqList$y, 
    matrix(as.matrix(varMatGpu)[centreCell,],Ngrid[1],Ngrid[2]),
    col = myCol$col, breaks=myCol$breaks)
mapmisc::legendBreaks("bottomright", myCol)


image(
    seqList$x, seqList$y, 
 matrix(as.matrix(varCpu)[centreCell,],Ngrid[1],Ngrid[2]),
    col = myCol$col, breaks=myCol$breaks)
mapmisc::legendBreaks("bottomright", myCol)
```

# extra info

```{r gpuInfo, echo=TRUE}
gpuR::gpuInfo()
```
