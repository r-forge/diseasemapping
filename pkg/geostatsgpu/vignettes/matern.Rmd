<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Matern correlations}
-->


# Matern correlations

```{r date}
date()
```


```{r packages}
library('geostatsp')
library('geostatsgpu')
```


Set up spatial data

```{r setupData}
# Ngrid = c(100, 100)
#Ngrid = c(50, 50)
Ngrid = c(30, 30)

seqList = list( 
    x = seq(1,by=1,len=Ngrid[1]), 
    y = seq(201,by=1,len=Ngrid[2])
    )

coordsSp = sp::SpatialPoints(
	as.matrix(expand.grid(seqList$x, seqList$y)))

myParams = c(shape=2.15, range=1.5, variance = 2, 
	nugget = 0, anisoRatio = 10, 
	anisoAngleRadians = pi/7)
```

Transfer coordinates to GPU and create matrix on GPU to hold the variance matrix
```{r gpuObjects}
coordsGpu = vclMatrix(coordsSp@coords)

varMatGpu <- vclMatrix(
    data=-1, 
    length(coordsSp), length(coordsSp),
    type='double')
```

Create matern matrix on gpu
```{r maternMatGpu}
system.time(varCpu <- geostatsp::matern(coordsSp, myParams, type='variance'))
system.time(geostatsgpu::maternGpu(x=coordsGpu, param=myParams, output=varMatGpu, type='variance'))
range(varCpu - as.matrix(varMatGpu))
```


# Cholesky

```{r cholSetup}

#setwd("~/workspaceOxygen/diseasemapping/pkg")
N = 75
control = list(
    workgroupSize = 1024,
    localWorkgroupSize = 128,
    sizeOfDouble = 8,
    localStorage = 4096/2
    )



myCoords = raster::as.data.frame(geostatsp::squareRaster(raster::extent(0,1,0,1), N), 
    xy=TRUE)[,1:2]

set.seed(0)
myCoords[,1] = myCoords[,1] + 
    rnorm(nrow(myCoords), sd=0.1)
myCoords[,2] = myCoords[,2]^(1/2) + 
    rnorm(nrow(myCoords), sd=0.1)


varMat = maternGpu(myCoords, param=c(range=1, shape=1.5, variance=2))
varMatR <- as.matrix(varMat)
```

```{r cholSetup2}
varMat1 = gpuR::deepcopy(varMat)
varMat2 = gpuR::deepcopy(varMat)
varMat3 = gpuR::deepcopy(varMat)

D = gpuR::vclVector(0, nrow(varMat),
            type='double',
            ctx_id = varMat@.context_index)

diagTimesRowOfA = gpuR::vclVector(0,
            nrow(varMat),
            type='double',
            ctx_id = varMat@.context_index)

diagWorking = gpuR::vclVector(0, 512,
    #1 + round(control$workgroupSize / control$localWorkgroupSize),
            type='double',
            ctx_id = varMat@.context_index)


file <- "../pkg/geostatsgpu/inst/CL/cholGpu.cl"
if(!file.exists(file)) {
file = system.file('CL/cholGpu.cl', 
    package='geostatsgpu')
}
kernel <- readChar(file, file.info(file)$size)
```

```{r cholGpu}
system.time(logDet <- geostatsgpu:::cpp_cholGpu(
        varMat1, D, diagWorking, diagTimesRowOfA,
        control$workgroupSize, 
        128, #control$localWorkgroupSize, 
        128*28,#control$localStorage,
        5000, #ncol(x)-512, #5000, 
        4, # Ncrossprod
        FALSE, # verbose
        kernel
        ))
```

```{r cholCpu}
system.time(cholR <- chol(varMatR))
xchold = diag(cholR)
cholTest = t((diag(1/xchold) %*% cholR))
DfromR = xchold^2
```

```{r cholGpuR}
system.time(x2Chol <- gpuR:::chol.vclMatrix(varMat2))
system.time(x3Chol <- luGpu(varMat3))
```

```{r cholCompare}
# check to see if diagTimesRowOfA is 
# the crossproduct
#Ngroups = control$workgroupSize / control$localWorkgroupSize
#Ncross = floor(sqrt(control$localStorage / control$localWorkgroupSize))

SSeq = seq(by=1, len=6, to=ncol(varMat))



#t(as.matrix(varMat1)[SSeq,SSeq])
cholTest[SSeq,SSeq]

cbind(DfromR[SSeq], as.vector(D)[SSeq], as.vector(x3Chol$D))


quantile(DfromR - as.vector(D), na.rm=TRUE)


quantile(as.vector(x3Chol$D) - DfromR)
x3CholR = as.matrix(x3Chol$L)
theLower = lower.tri(x3CholR, diag=FALSE)
quantile(x3CholR[theLower] - cholTest[theLower])

c(logDet, sum(log(DfromR)), x3Chol$logDet)
```



```{r diagPlot, fig.cap='comparing choleskies', fig.subcap=c('off diag', 'diag'), eval=FALSE}
Dcol = ncol(varMat)
plot(cholTest[Dcol,] - as.matrix(varMat1)[ , Dcol])

plot(as.vector(D) - DfromR)
```


```{r devtools}
#Rcpp::compileAttributes('..')
#devtools::document("..")
#devtools::install("..")
#devtools::reload("..")
```

```{r maternMatGpuChol, eval=FALSE}
cholVarGpu <- list(
    L = vclMatrix(
        data=-1, 
        length(coordsSp), length(coordsSp),
        type='double'),
    D = vclVector(data = -1, length=length(coordsSp), type='double')
    )

system.time(cholVarCpu <- geostatsp::matern(coordsSp, myParams, type='cholesky'))
system.time(fromGpu <- geostatsgpu::maternGpu(x=coordsGpu, param=myParams, output=cholVarGpu$L, DofLDL = cholVarGpu$D, type='cholesky'))

fromGpu$det 
sum(log(diag(cholVarCpu)))*2
```

```{r checkChol, eval=FALSE}
library('Matrix')
ldlL = new('dtrMatrix', x=as.vector(as.matrix(cholVarGpu$L)), Dim = dim(cholVarGpu$L), uplo='L')
ldlD = Diagonal(ncol(cholVarGpu$L),as.vector(cholVarGpu$D))

cholL = as(ldlL %*% sqrt(ldlD), 'dtrMatrix')

ldlL[1:5,1:5]
cholL[1:5,1:5]
range(cholL- cholVarCpu)
```


```{r compare, eval=FALSE}
centreCell = floor(prod(Ngrid)/2)+floor(Ngrid[2]/2)

myCol = mapmisc::colourScale(c(0, myParams['variance']),
    breaks = 9, dec=1, style='equal', transform='sqrt')

image(
    seqList$x, seqList$y, 
    matrix(as.matrix(varMatGpu)[centreCell,],Ngrid[1],Ngrid[2]),
    col = myCol$col, breaks=myCol$breaks)
mapmisc::legendBreaks("bottomright", myCol)


image(
    seqList$x, seqList$y, 
 matrix(as.matrix(varCpu)[centreCell,],Ngrid[1],Ngrid[2]),
    col = myCol$col, breaks=myCol$breaks)
mapmisc::legendBreaks("bottomright", myCol)
```

# extra info

```{r gpuInfo, echo=TRUE}
gpuR::gpuInfo()
```


```{r cholDebug, eval=FALSE, include=FALSE}
    file <- "geostatsgpu/inst/CL/cholGpu.cl"
    file <- system.file("CL", "cholGpu.cl", package = "geostatsgpu")

myCoords = raster::as.data.frame(geostatsp::squareRaster(raster::extent(0,1,0,1), 60), xy=TRUE)[,1:2]
set.seed(0)
myCoords[,1] = myCoords[,1] + rnorm(nrow(myCoords), sd=0.1)
myCoords[,2] = myCoords[,2]^(1/2)+rnorm(nrow(myCoords), sd=0.1)

x1 = as.matrix(geostatsp::matern(
    param=c(range=1, shape=1, variance=2),
    x=sp::SpatialPoints(myCoords)
    ))

x = gpuR::vclMatrix(x1)

        D = gpuR::vclVector(0, nrow(x),
            type='double',
            ctx_id = x@.context_index)

   kernel <- readChar(file, file.info(file)$size)

        localInfo = geostatsgpu:::gpuNlocal(
            kernel, 
            'sumLog',
            x@.device_index)

            MCtotal = localInfo$maxWorkgroupSize
            MClocal = localInfo$localWorkgroupSize
            sizeofDouble = localInfo$sizeOfDouble
            localStorage = 
            floor(
                localInfo$localMemory / 
                sizeofDouble)-2

    fromC = geostatsgpu:::cpp_cholGpu(
        x@address, 
        D@address,
        MCtotal,
        MClocal, 
        localStorage,
        x@.context_index - 1,
        kernel
        )
xchol = chol(x1)
xchold = diag(xchol)
cholTest = t((diag(1/xchold) %*% xchol))
gpuTest = as.matrix(x)
gpuTest = t(gpuTest)
quantile(
    gpuTest[lower.tri(gpuTest, diag=FALSE)] - 
    cholTest[lower.tri(gpuTest, diag=FALSE)])



xtest = cbind(
    xchold^2 , as.vector(D), xchold^2 - as.vector(D)
    )
#xtest#[1:40,]
#quantile(abs(xtest[,3]))



min(which(abs(xtest[,3]) > 0.1))

theSeq = 1:9
round(gpuTest[theSeq, theSeq],2)
round(cholTest[theSeq, theSeq],2)
cbind(gpuTest[,6], cholTest[,6])


max(apply( (cholTest - gpuTest),2,sd))

theSeq = 10:15
cholTest[theSeq,theSeq]
gpuTest[theSeq,theSeq]
as.vector(D)[theSeq]
(xchold^2)[theSeq]

range( (cholTest - gpuTest)[1:15,1:15])

#t(apply(cholTest - gpuTest, 2, range))


#(round(cholTest - gpuTest, 4))[1:60,1:9]
```



# To do

- fix crossprod

    - put crossprod in A and check it's ok
- each workgroup a row

    - use some of diagLocal for within-group sums
- dont store upper triangle in crossprod
- replace * with += for some iterators

