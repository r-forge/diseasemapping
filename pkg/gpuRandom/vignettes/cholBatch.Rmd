<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{cholBatch}
-->


## Chol
```{r package}
#library(Matrix)

```


```{r cpu_function}
a1 = matrix(c(25,15,-5,15,18,0,-5,0,11),nrow=3,ncol=3,byrow=TRUE)
x <- chol(a1)   ## start from factor given by chol
y <- diag(x)   ## extract sqrt(D)
L1 <- t(x/y)     ## get unit lower triangular factor
D1 <- diag(x^2)  ## and diagonal


a2 = matrix(c(2,5,-5,5,16,3,-5,3,85),nrow=3,ncol=3, byrow=TRUE)
x <- chol(a2)   ## start from factor given by chol
y <- diag(x)   ## extract sqrt(D)
L2 <- t(x/y)     ## get unit lower triangular factor
D2 <- diag(x^2)  ## and diagonal


A1 = cbind(c(0,0,0,0), rbind(c(0,0,0),a1))  #4x4
A2 = cbind(c(0,0,0,0), rbind(c(0,0,0),a2))

rbind(A1,A2)
L1;D1;L2;D2
```

```{r chol_two_batch}
gpuA<-vclMatrix(rbind(A1,A2),type="float")
diagMat = vclMatrix(0, 3, ncol(A1), type = "float")
NglobalChol =  c(4,4,0)
NlocalChol = c(2,4,0)
NlocalCache = 100
gpuRandom:::cholBatchBackend(gpuA, diagMat, c(1,3,1,3), c(1,2,0,3), 2L,
                             NglobalChol, NlocalChol, NlocalCache)

as.matrix(gpuA)
as.matrix(diagMat)
```









```{r chol_R_function}
rbind(a1,a2)
a<-vclMatrix(rbind(a1,a2),type="float")
diagMat = vclMatrix(0, 2, ncol(a1), type = "float")
result<-gpuRandom::cholBatch(a, diagMat, numbatchD=2L,
                             Nglobal=NglobalChol, Nlocal=NlocalChol, NlocalCache=NlocalCache)

L1;D1;L2;D2
as.matrix(a)
as.matrix(diagMat)
```

```{r chol test Nov22, eval=F}
 Nsim = 4
   Ngrid = c(5,10)
   NlocalCache = 300
    NglobalMatern = c(64,8) 
    NlocalMatern = c(8, 4)
   NglobalChol =  c(16,8,4)
    NglobalChol =  c(64,8)
    NlocalChol = c(16, 8)
    NglobalRandom = c(64,4)
  NglobalMult = c(16,4,4)   
  NlocalMult = c(4,4,1)   
theType = "float"


NlocalMatern = c(2,2)


if(gpuR::gpuInfo()$deviceMemory > 10^10){
   Ngrid = c(5,10)
   Nsim = 6
   NlocalCache = 4000
   NglobalMatern = c(256,8) 
   NlocalMatern = c(32, 8)
   NglobalChol =  c(128,8)
   NlocalChol = c(16, 8)
   NglobalRandom = c(512,8)
   NglobalMult = c(64,8,8)   
   NlocalMult = c(8,8,1)
   theType = "double"
}

myRaster = raster::raster(
    raster::extent(0,Ngrid[1]/Ngrid[2],5,6),
    Ngrid[1], Ngrid[2]
  )
coordsSp = sp::SpatialPoints(raster::xyFromCell(myRaster, 1:raster::ncell(myRaster)))

head(coordsSp@coords,15)

myParamsBatch = rbind(
c(shape=1.25, range=5, variance = 1.5, nugget = 0, anisoRatio = 1, anisoAngleRadians = 0), 
c(shape=2.15, range=10, variance = 2, nugget = 0, anisoRatio = 4, anisoAngleRadians = pi/7),
c(shape=0.55, range=15, variance = 2, nugget = 0, anisoRatio = 4,  anisoAngleRadians = pi/7))

myParamsBatch = t(apply(myParamsBatch, 1, geostatsp::fillParam))
myParamsBatch = cbind(myParamsBatch, matrix(0, nrow(myParamsBatch), 22-ncol(myParamsBatch)))

coordsGpu = vclMatrix(coordsSp@coords, nrow(coordsSp@coords), ncol(coordsSp@coords), type=theType)
paramsGpu = vclMatrix(myParamsBatch, type=gpuR::typeof(coordsGpu))
outputBatchF = vclMatrix(0, nrow(paramsGpu)*nrow(coordsGpu), nrow(coordsGpu), type=gpuR::typeof(paramsGpu))

############ matern gpu ###################
gpuRandom:::maternBatchBackend(outputBatchF,coordsGpu, paramsGpu,  Nglobal = NglobalMatern, Nlocal = NlocalMatern)
dim(outputBatchF)
as.matrix(outputBatchF[1:12,1:7])

########### matern cpu ##################
var4cpu = geostatsp::matern(
    x=coordsSp,
    param=drop(myParamsBatch[1,1:7])
    )

var4cpu[1:12,1:7]
dim(var4cpu)
as.matrix(outputBatchF[1:50,])-var4cpu


################chol gpu ####################
diagMat = vclMatrix(0, nrow(paramsGpu), ncol(outputBatchF), type = gpuR::typeof(outputBatchF))
#outputChol = vclMatrix(0, nrow(outputBatchF), ncol(outputBatchF), type = gpuR::typeof(outputBatchF))

gpuRandom::cholBatch(outputBatchF, diagMat, numbatchD=nrow(myParamsBatch),Nglobal = NglobalChol,Nlocal = NlocalChol,NlocalCache = NlocalCache)

as.matrix(outputBatchF[1:12,1:7])
as.matrix(diagMat)
dim(outputBatchF)

##############chol cpu############################
cholCpu = as.matrix(chol(var4cpu))
theDiag = diag(cholCpu)
cholCpu = cholCpu %*% diag(1/theDiag)
theDiag = theDiag^2


########### check chol result####################
as.matrix(outputBatchF[1:50,40:50])-cholCpu[,40:50]
as.matrix(diagMat[1,])-theDiag


```


```{r chol test Nov23, eval=F}
library('geostatsp')
data('swissRain')
sr2 = swissRain[1:20,]

# extract variables for modeling
sr2$sqrtY = sqrt(sr2$rain)
sr2$elev = raster::extract(swissAltitude, sr2)

swissFitIso = likfitLgm(
  data=sr2,
  formula=sqrtY ~ elev,
  param=c(range=10,shape=1,nugget=0),
  reml=FALSE,
  verbose=FALSE
)

swissFitIso$parameters

newParamList = list(
  range=seq(15, 50 , len=3)*1000,
  nugget = seq(0.01,0.5,len=3)
)
newParam= do.call(expand.grid, newParamList)

otherparams = c(shape=1, variance = 1.5, anisoRatio = 1, anisoAngleRadians = 0)
otherparams = matrix(rep(otherparams,each=nrow(newParam)),nrow=nrow(newParam))
colnames(otherparams) <- c("shape","variance", "anisoRatio", "anisoAngleRadians")
paramsBatch0 = cbind(newParam, otherparams)
paramsBatch0 = t(apply(paramsBatch0, 1, geostatsp::fillParam))
paramsBatch = vclMatrix(cbind(paramsBatch0, matrix(0, nrow(paramsBatch0), 22-ncol(paramsBatch0))),type="double")
paramscpu<-as.matrix(paramsBatch)
workgroupSize=c(64,16,16)
localSize = c(4,4,1)
NlocalCache=50

betas=NULL
form="ml"
type="double"
covariates = model.matrix(swissFitIso$model$formula, data=swissFitIso$data)
temp = model.frame(swissFitIso$model$formula, data=swissFitIso$data)
response=temp[,as.character(attributes(terms(temp))$variables)[2]]
yX=vclMatrix(cbind(response,covariates),type=type)
coordsGpu<-vclMatrix(sr2@coords,type=type)
n = length(response)
p = ncol(covariates)


 form = c(loglik=1, ml=2, mlFixSigma=3, mlFixBeta=4, reml=5, remlPro=6)[form]
 rowbatch = nrow(paramsBatch)
 colbatch = 1     #colbatch = ncol(y)
   
 localSizechol<-localSize
 localSizechol[2]<-workgroupSize[2]
    
 Vbatch = vclMatrix(0, nrow(paramsBatch)*n, n, type = type)
 diagMat = vclMatrix(0, nrow(paramsBatch), n, type = type) 
     
     #ycpu<-as.matrix(y)
     #xcpu<-as.matrix(X)
     
  # 
 gpuRandom:::maternBatchBackend(Vbatch, coordsGpu, paramsBatch,  workgroupSize, localSize)
 vbatchcpu<-as.matrix(Vbatch)
 vbatchcpu[1:4,1:4]
 var4cpu[1:4,1:4]
 diag(vbatchcpu[1:20,])
     
 #createspatialpoints <- SpatialPoints(sr2@coords)
 var4cpu = geostatsp::matern(
      x=sr2,
      param=drop(paramsBatch0[1,1:7]))
 
 quantile(var4cpu-vbatchcpu[1:20,])
     
 dim(var4cpu)
 vbatchcpu[1:20,]-var4cpu
 diag(vbatchcpu[1:20,])-diag(var4cpu)









    

#3#######333333333######## chol gpu#########
    gpuRandom::cholBatch(Vbatch, diagMat, numbatchD=rowbatch, Nglobal=workgroupSize, Nlocal=localSizechol, NlocalCache=NlocalCache)
    
    #vbatchcpu<-as.matrix(Vbatch)
    Dcpu<-as.matrix(diagMat)

```







```{r cholBatchCpu, include=FALSE, eval=F}
cholCpu = as.matrix(chol(var4cpu))
theDiag = diag(cholCpu)
cholCpu = cholCpu %*% diag(1/theDiag)
theDiag = theDiag^2

chol4gpu = as.matrix(outputChol[seq(1+3*nrow(coordsGpu), len=nrow(coordsGpu)),])
chol4gpu[upper.tri(chol4gpu)] = 0
diag(chol4gpu) = 1

chol4gpu[1:4,1:4]
cholCpu[1:4,1:4]
range(cholCpu - as.matrix(chol4gpu))

range(theDiag - as.matrix(diagMat)[4,])
```





```{r crossprodbatch2, eval=TRUE}
a1 = matrix(1:160,40,4)
a2=matrix(2:161,40,4)
A=rbind(a1,a2,a1,a2)
d1 <- matrix(0,nrow=nrow(a1), ncol=nrow(a1))
diag(d1)<-1:nrow(a1)
d2 <- matrix(0,nrow=nrow(a2), ncol=nrow(a2))
diag(d2)<-1:nrow(a2)

result<-rbind(t(a1)%*% d1%*%a1,t(a2)%*% d2%*%a2,t(a1)%*% d1%*%a1,t(a2)%*% d2%*%a2)

D<-rbind(diag(d1),diag(d2),diag(d1),diag(d2))

library(gpuR)
gpuC<-vclMatrix(0, nrow=ncol(A)*4, ncol=ncol(A),type="double")
gpuA<-vclMatrix(A,type="double")
gpuD<-vclMatrix(D, nrow=nrow(D),ncol=ncol(D),type='double')
gpuRandom:::crossprodBatchBackend(gpuC,gpuA,gpuD,invertD=FALSE,
                                  Nglobal=c(16,16,1), 
                                  Nlocal = c(2,2,1), 
                                  NlocalCache=50)

cbind(as.matrix(gpuC), NA,  result)













a1 = matrix(1:72,6,9)
a2=matrix(2:73,6,9)
A=rbind(a1,a2,a1,a2)
d1 <- matrix(0,nrow=nrow(a1), ncol=nrow(a1))
diag(d1)<-1:nrow(a1)
d2 <- matrix(0,nrow=nrow(a2), ncol=nrow(a2))
diag(d2)<-1:nrow(a2)

result<-rbind(t(a1)%*% d1%*%a1,t(a2)%*% d2%*%a2,t(a1)%*% d1%*%a1,t(a2)%*% d2%*%a2)

D<-rbind(diag(d1),diag(d2),diag(d1),diag(d2))

library(gpuR)
gpuC<-vclMatrix(0, nrow=ncol(A)*4, ncol=ncol(A),type="double")
gpuA<-vclMatrix(A,type="double")
gpuD<-vclMatrix(D, nrow=nrow(D),ncol=ncol(D),type='double')
gpuRandom:::crossprodBatchBackend(gpuC,gpuA,gpuD,invertD=FALSE,
                                  Nglobal=c(16,16,1), 
                                  Nlocal = c(2,2,1), 
                                  NlocalCache=50)

cbind(as.matrix(gpuC), NA,  result)
```

```{r crossprodbatch_square, eval=TRUE}
a1 = matrix(1:16,4,4)
a2=matrix(2:17,4,4)
A=rbind(a1,a2,a1,a2)
d1 <- matrix(0,nrow=nrow(a1), ncol=nrow(a1))
diag(d1)<-1:nrow(a1)
d2 <- matrix(0,nrow=nrow(a2), ncol=nrow(a2))
diag(d2)<-1:nrow(a2)

result<-rbind(t(a1)%*% d1%*%a1,t(a2)%*% d2%*%a2,t(a1)%*% d1%*%a1,t(a2)%*% d2%*%a2)

D<-rbind(diag(d1),diag(d2),diag(d1),diag(d2))

library(gpuR)
gpuC<-vclMatrix(0, nrow=ncol(A)*4, ncol=ncol(A),type="double")
gpuA<-vclMatrix(A,type="double")
gpuD<-vclMatrix(D, nrow=nrow(D),ncol=ncol(D),type='double')
gpuRandom:::crossprodBatchBackend(gpuC,gpuA,gpuD,invertD=FALSE,
                                  Nglobal=c(16,16,1), 
                                  Nlocal = c(2,2,1), 
                                  NlocalCache=50)

cbind(as.matrix(gpuC), NA,  result)
```


```{r crossprodbatch_rectangular, eval=TRUE}
D <- matrix(0,nrow=3, ncol=3)
diag(D)<-c(1,8,3)
D
A = matrix(c(1,0,0,0,1,0),nrow=3,ncol=2, byrow=T)
A
result<- t(A)%*% D%*%A
result
gpuC<-vclMatrix(0, nrow=2, ncol=2,type="float")
gpuA2<-vclMatrix(A,type="float")
gpuD<-vclMatrix(diag(D), nrow=1,ncol=3,type='float')
gpuRandom:::crossprodBatchBackend(gpuC,gpuA2,gpuD,invertD=F, c(1,1,1),c(1,1,1), 1000)
as.matrix(gpuC)
```


```{r crossprodbatch_more, eval=TRUE}
D <- matrix(0,nrow=40, ncol=40)
diag(D)<-c(1:40)
a = matrix(1:40,nrow=40,ncol=1, byrow=T)
A=rbind(a,a,a,a)
result<- t(a)%*% D%*%a
result
gpuC<-vclMatrix(0, nrow=4, ncol=1,type="float")
gpuA<-vclMatrix(A,type="float")
gpuD<-vclMatrix(rbind(diag(D),diag(D),diag(D),diag(D)), nrow=4,ncol=40,type='float')
gpuRandom:::crossprodBatchBackend(gpuC,gpuA,gpuD,invertD=F, NglobalChol,NlocalChol, NlocalCache)
as.matrix(gpuC)


gpuC2<-vclMatrix(0, nrow=1, ncol=1,type="float")
gpuA2<-vclMatrix(a,type="float")
gpuD2<-vclMatrix(diag(D), nrow=1,ncol=40,type='float')
gpuRandom:::crossprodBatchBackend(gpuC2,gpuA2,gpuD2,invertD=F, NglobalChol,NlocalChol, NlocalCache)
as.matrix(gpuC2)




```






