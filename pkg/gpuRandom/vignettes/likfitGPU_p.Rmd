<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{loglikelihood_p}
-->

```{r makeplots,eval=TRUE}
# isotropic
library(gpuRandom)
library(gpuR)
library('geostatsp')
data('swissRain')
sr2 = swissRain[0:30,]

# extract variables for modeling
sr2$sqrtY = sqrt(sr2$rain)
sr2$elev = raster::extract(swissAltitude, sr2)


spatialmodel = geostatsp::likfitLgm(
  data=sr2,
  formula=sqrtY ~ elev,
  param=c(range=50000,shape=1),
  reml=FALSE,
  verbose=FALSE
)
spatialmodel$parameters
newParamList = list(
  range=seq(30000, 80000 , len=40),
  nugget = seq(0,0.25,len=10)
) 


newParam= do.call(expand.grid, newParamList)

otherparams = c(shape=1, variance=1.840997, anisoRatio = 1, anisoAngleRadians = 0)
otherparams = matrix(rep(otherparams,each=nrow(newParam)),nrow=nrow(newParam))
colnames(otherparams) <- c("shape", "variance", "anisoRatio", "anisoAngleRadians")

paramsBatch0 = cbind(newParam, otherparams)
paramsGpu = gpuRandom::maternGpuParam(paramsBatch0, type="double")

type = "double"
BoxCox=c(1,0)
form = "ml"
NparamPerIter=40  # how many sets of params to be evaluated in each loop



result<-gpuRandom::likfitGpu_2(spatialmodel,     #data,
            type = "double",
            paramsGpu, #a vclmatrix, consists of all the parameters#betas=NULL, #a vclmatrix  #only one row batch, but many colbatches
            BoxCox=c(1,0), # an R vector, will always be c(1,0,.....)
            form = "ml",
            NparamPerIter,  # how many sets of params to be evaluated in each loop
            nBetahats =1,
            minustwotimes=TRUE,
            Nglobal=c(64,32,2),
            Nlocal=c(8,16,1),
            NlocalCache=1000)


mTwoLogLik <- as.matrix(result$minusTwoLogLik)



lMatrix = matrix(mTwoLogLik[,1], length(newParamList[[1]]), length(newParamList[[2]]))
# 
myCol = mapmisc::colourScale(lMatrix, breaks=8, dec=0)
image(
  newParamList[[1]]/1000, newParamList[[2]], lMatrix,
  col = myCol$col, breaks=myCol$breaks,
  xlab = names(newParamList)[1],
  ylab = names(newParamList)[2]
)
mapmisc::legendBreaks('topright', myCol)


#mTwoLogLik 
as.vector(result$detVar)[1:50]

as.vector(result$detReml)[1:50]


as.matrix(result$ssqY)[1:50,]
as.matrix(result$ssqYX)[1:50,]
result$Betahats

```







```{r setup, include=FALSE}
library(geostatsp)
set.seed(1)
n=20
mydat = SpatialPointsDataFrame(cbind(stats::runif(n), seq(0,1,len=n)),
                               data=data.frame(cov1 = stats::rnorm(n), cov2 = stats::rpois(n, 2)))

# simulate a random field
mydat@data= cbind(mydat@data , RFsimulate(model=c(variance=1.5,range=0.5,nugget=0.25,shape=1.25,anisoRatio = 1, anisoAngleRadins=0),x=mydat)@data)

# add fixed effects
# exponentiate to make positive and enable boxcox
mydat$Y = -3 + 0.5*mydat$cov1 + 0.2*mydat$cov2 + mydat$sim + stats::rnorm(length(mydat), 0, sd=sqrt(0.25))
mydat$Yexp = exp(mydat$Y)
```

















```{r patrickTest, eval=F}
library(gpuR)

params = rbind(c(shape=1.25, range=0.2641423, variance = 1.5, nugget = 0, anisoRatio = 1, anisoAngleRadians = 0),
                    c(shape=1.25, range=0.5, variance = 1.5, nugget = 0.25, anisoRatio = 1, anisoAngleRadians = 0),
                    c(shape=2.25, range=0.5, variance = 2.5, nugget = 2.25, anisoRatio = 1, anisoAngleRadians = 0))
 # c(shape=1.25, range=0.5, variance = 1.5, nugget = 0.25, anisoRatio = 1, anisoAngleRadians = 0))
#paramsBatch = rbind(c(shape=3, range=11.5247874, variance = 5.5, nugget = 0.6932729, anisoRatio = 1, anisoAngleRadians = 0))


x = mydat
boxcox = c(0, 0.5)
Scov = c('cov1','cov2')
yvar = 'Yexp'
NparamPerIter = 2

workgroupSize = c(1,1,1)
  localSize = c(1,1,1)
NlocalCache=500
type='double'
verbose = 9L


if(boxcox[1] != 1) {
  boxcox = c(1, 0, setdiff(boxcox, c(0,1)))
}
Ncov = length(Scov)+1
Ndata = length(boxcox)
Nparam = nrow(params)

paramsBatch1 = t(apply(params, 1, geostatsp::fillParam))
paramsBatch = vclMatrix(
  cbind(paramsBatch1, matrix(0, nrow(paramsBatch1), 22-ncol(paramsBatch1))),
  type=type)

yx = vclMatrix(cbind(
  as.vector(x@data[,yvar]),
  matrix(0, nrow(x@data), length(boxcox)-1),
  1,
  as.matrix(x@data[,Scov])
), type=type)
coords = vclMatrix(x@coords, type =type)

boxcoxGpu = vclVector(boxcox, type=type)
betas = vclMatrix(0, Nparam, Ncov * Ndata, type=type)
detVar = vclVector(0, Nparam,type=type)
detReml = vclVector(0, Nparam, type=type)
jacobian = vclVector(0, Ndata, type=type)
ssqY <- vclMatrix(0, Nparam, Ndata, type=type)
ssqX <- vclMatrix(0, Nparam, Ndata, type=type)
ssqBeta = deepcopy(ssqX)
ssqBetaHat = deepcopy(ssqXs)

# objects for debugging
ssqYX = vclMatrix(0, ncol(yx) * NparamPerIter, ncol(yx), type=type)
LinvYX = vclMatrix(0, nrow(yx) * NparamPerIter, ncol(yx), type=type)
varMat = vclMatrix(0, nrow(yx)*NparamPerIter, nrow(coords), type=type)

cholDiagMat = vclMatrix(0, NparamPerIter, nrow(coords), type=type)
b_beta = vclMatrix(0, NparamPerIter*nrow(yx), Ndata, type=type)

gpuRandom:::likfitGpu_BackendP(
  yx,
  coords,
  paramsBatch,
  boxcoxGpu,
  betas,
  ssqY,
  ssqX,
  detVar,
  detReml,
  jacobian,
  NparamPerIter,
  workgroupSize,
  localSize,
  NlocalCache,
  verbose = 20,
  ssqYX, LinvYX,
  cholDiagMat,
  b_beta  #new  26

)


as.vector(detVar)
as.vector(detReml)
as.matrix(ssqX)
as.matrix(ssqY)

as.vector(jacobian)
head(as.matrix(yx)) 
```





```{r localmemorystuff10.5}
library(gpuRandom)
library(gpuR)
library('geostatsp')
data('swissRain')
sr2 = swissRain[0:20,]

# extract variables for modeling
sr2$sqrtY = sqrt(sr2$rain)
sr2$elev = raster::extract(swissAltitude, sr2)

newParamList = list(
  range=seq(30000, 80000 , len=20),
  nugget = seq(0,0.25,len=10)
) 


newParam= do.call(expand.grid, newParamList)

otherparams = c(shape=1, variance=1.840997, anisoRatio = 1, anisoAngleRadians = 0)
otherparams = matrix(rep(otherparams,each=nrow(newParam)),nrow=nrow(newParam))
colnames(otherparams) <- c("shape", "variance", "anisoRatio", "anisoAngleRadians")

paramsBatch0 = cbind(newParam, otherparams)
#paramsBatch0 = t(apply(paramsBatch0, 1, geostatsp::fillParam))
paramsGpu = gpuRandom::maternGpuParam(paramsBatch0, type="double")
#paramsGpu = gpuR::vclMatrix(cbind(paramsBatch0, matrix(0, nrow(paramsBatch0),22-ncol(paramsBatch0))),type="double")




x = sr2
boxcox = c(0, 0.5)
Scov = c('elev')
yvar = 'sqrtY'

# this setting works
workgroupSize = c(64,64,4)
localSize = c(4,4,2)
NlocalCache=1000
verbose = 9L


if(boxcox[1] != 1) {
  boxcox = c(1, 0, setdiff(boxcox, c(0,1)))
}
Ncov = length(Scov)+1
Ndata = length(boxcox)    # =3
Nparam = nrow(paramsGpu)  # =8
# 20*20


type="double"
yx = vclMatrix(cbind(
  as.vector(x@data[,yvar]),
  matrix(0, nrow(x@data), length(boxcox)-1),
  1,
  as.matrix(x@data[,Scov])
), type=type)
coords = vclMatrix(x@coords, type =type)

boxcoxGpu = vclVector(boxcox, type=type)
betas <- matrix(c(4.441053, 5.809251e-05),nrow=2, ncol=Ndata)
betas = vclMatrix(betas, type=type)
#betas = vclMatrix(0,0,0, type=type)

detVar = vclVector(0, Nparam,type=type)
detReml = vclVector(0, Nparam, type=type)
jacobian = vclVector(0, Ndata, type=type)
ssqY <- vclMatrix(0, Nparam, Ndata, type=type)
ssqBetahat <- vclMatrix(0, Nparam, Ndata, type=type)
ssqBeta <- vclMatrix(0, Nparam, Ndata, type=type)

NparamPerIter = 20

# objects for debugging
ssqYX = vclMatrix(0, ncol(yx) * NparamPerIter, ncol(yx), type=type)
aTDinvb_beta = vclMatrix(0, Nparam, Ndata, type=type)
XVYXVX = vclMatrix(-77, Nparam * Ncov, ncol(yx), type=type)
#ssqYXcopy = vclMatrix(0, ncol(yx) * NparamPerIter, ncol(yx), type=type)
LinvYX = vclMatrix(0, nrow(yx) * NparamPerIter, ncol(yx), type=type)
QinvSsqYx = vclMatrix(0, NparamPerIter*Ncov, Ndata, type = type)
varMat = vclMatrix(0, nrow(yx)*NparamPerIter, nrow(coords), type=type)
cholXVXdiag = vclMatrix(0, NparamPerIter, Ncov, type=type)
cholDiagMat = vclMatrix(0, NparamPerIter, nrow(coords), type=type)
b_beta = vclMatrix(0, NparamPerIter*nrow(yx), Ndata, type=type)

gpuRandom:::likfitGpu_BackendP(
  yx,  #1
  coords,
  paramsGpu,
  boxcoxGpu,  
  betas,  #5
  ssqY,
  aTDinvb_beta,
  XVYXVX,
  ssqBetahat,
  ssqBeta,
  detVar,
  detReml,
  jacobian,  #13
  NparamPerIter,  
  workgroupSize,  
  localSize,  
  NlocalCache,  
  verbose = 0,  #18
  ssqYX, #ssqYXcopy,  #new
  LinvYX,  #21
  QinvSsqYx, 
  cholXVXdiag, #23
  varMat, #new
  cholDiagMat,
  b_beta)   #new  26

any(is.na(as.vector(detVar)))
any(is.na(as.matrix(varMat)))

as.vector(detVar)[1:50]
as.vector(detReml)


if(FALSE) {
as.matrix(ssqBetahat)[1:10,]
is.na(as.matrix(ssqBetahat))
as.matrix(ssqBeta)
as.matrix(ssqY)
as.matrix(aTDinvb_beta)
as.matrix(ssqYX)
any(is.na(as.matrix(ssqYX)))
as.matrix(XVYXVX)
as.vector(jacobian)
as.matrix(b_beta)
as.matrix(cholDiagMat)
as.matrix(varMat)

any(is.na(as.matrix(varMat)))
which(is.na(as.matrix(varMat)))

}



```



















